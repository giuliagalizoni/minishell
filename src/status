./export.c:	if (!msh->command->arguments[1])
./export.c:		sort_vars_list(msh->myenv);
./export.c:		print_vars(msh->myenv);
./export.c:	while (msh->command->arguments[i])
./export.c:		new_var = parse_var(msh->command->arguments[i]);
./export.c:			add_or_update_var(&msh->myenv, new_var->key, new_var->value);
./builtin_utils.c:	if (is_equal(msh->command->name, "exit"))
./builtin_utils.c:	else if (is_equal(msh->command->name, "echo"))
./builtin_utils.c:		echo(msh->command);
./builtin_utils.c:	else if (is_equal(msh->command->name, "export"))
./builtin_utils.c:	else if (is_equal(msh->command->name, "env"))
./builtin_utils.c:		print_env(msh->myenv);
./builtin_utils.c:	else if (is_equal(msh->command->name, "cd"))
./builtin_utils.c:		status = cd(msh->command);
./builtin_utils.c:	else if (is_equal(msh->command->name, "pwd"))
./builtin_utils.c:	else if (is_equal(msh->command->name, "unset"))
./unset.c:	if (!msh->command->arguments[1])
./unset.c:	while (msh->command->arguments[i])
./unset.c:		find_and_delete(&msh->myenv, msh->command->arguments[i]);
./executer.c:	if (msh->command->input_redirect)
./executer.c:		input_redirection(msh->command);
./executer.c:	if (msh->command->outfile)
./executer.c:		output_redirection(msh->command->outfile);
./executer.c:	if (msh->command->index < msh->num_cmds - 1)
./executer.c:	if (msh->command->input_redirect)
./executer.c:		input_redirection(msh->command);
./executer.c:	if (msh->command->outfile)
./executer.c:		output_redirection(msh->command->outfile);
./executer.c:	if (is_builtin(msh->command->name))
./executer.c:		execve(msh->command->path, msh->command->arguments, NULL);
./executer.c:	if (msh->command->index < msh->num_cmds - 1)
./executer.c:	if (msh->num_cmds == 1 && is_builtin(msh->command->name))
./executer.c:	first_command = msh->command;
./executer.c:	while (msh->command)
./executer.c:		if (msh->command->index < msh->num_cmds - 1 && msh->num_cmds > 1)
./executer.c:		msh->command->pid = pid;
./executer.c:		msh->command = msh->command->pipe_next;
./expand_var.c:	exit_status_str = ft_itoa(msh->exit_status);
./expand_var.c:	value = get_var_value(msh->myenv, key);
./exit.c:	clear_command_chain(msh->command);
./exit.c:	clean_myenv(msh->myenv);
./parser.c:		// printf("key %s has value \"%s\"\n", key, get_var_value(msh->myenv, key));
./parser.c:		arr_push(&command->arguments, get_var_value(msh->myenv, key));
./parser.c:	msh->command = analyser(retokens, 0, envp, msh);
./parser.c:	return (msh->command);
